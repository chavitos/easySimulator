//
//  SimulatorResultViewControllerTests.swift
//  easySimulator
//
//  Created by Tiago Chaves on 26/08/2018.
//  Copyright (c) 2018 easynvest. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import easySimulator
import XCTest

class SimulatorResultViewControllerTests: XCTestCase
{
    // MARK: Subject under test
    
    var sut: SimulatorResultViewController!
    var window: UIWindow!
    
    // MARK: Test lifecycle
    
    override func setUp()
    {
        super.setUp()
        window = UIWindow()
        setupSimulatorResultViewController()
    }
    
    override func tearDown()
    {
        window = nil
        super.tearDown()
    }
    
    // MARK: Test setup
    
    func setupSimulatorResultViewController()
    {
        let bundle = Bundle.main
        let storyboard = UIStoryboard(name: "Main", bundle: bundle)
        sut = storyboard.instantiateViewController(withIdentifier: "SimulatorResultViewController") as! SimulatorResultViewController
    }
    
    func loadView()
    {
        window.addSubview(sut.view)
        RunLoop.current.run(until: Date())
    }
    
    // MARK: Test doubles
    
    class SimulatorResultBusinessLogicSpy: SimulatorResultBusinessLogic, SimulatorResultDataStore
    {
        var simulationResult: SimulationResult?
        var getSimulationResultCalled = false
        
        func getSimulationResult() {
            
            getSimulationResultCalled = true
        }
    }
    
    // MARK: Tests
    
    func testShouldGetSimulationresultWhenViewIsLoaded(){
        // Given
        let interactorSpy = SimulatorResultBusinessLogicSpy()
        interactorSpy.simulationResult = Seeds.SimulationResults.simulationResult
        sut.interactor = interactorSpy
        
        // When
        loadView()
        
        // Then
        XCTAssertTrue(interactorSpy.getSimulationResultCalled, "viewDidLoad() should ask the interactor to get simulation result")
    }
    
    func testDisplaySimulationResultShouldDisplayFormattedResulInTextFields(){
        
        let interactorSpy = SimulatorResultBusinessLogicSpy()
        interactorSpy.simulationResult = Seeds.SimulationResults.simulationResult
        sut.interactor = interactorSpy
        let viewModel = SimulatorResult.GetSimulationResult.ViewModel(displayResult: Seeds.SimulationResults.simulationResultDisplay)
        
        loadView()
        sut.displaySimulationResult(viewModel: viewModel)
        
        var expectGrossAmount:XCTestExpectation? = expectation(description: "Wait for update gross amount label")
        let observeGrossAmount = sut.grossAmountLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.grossAmount
            
            // Then
            expectGrossAmount!.fulfill()
            expectGrossAmount = nil
            XCTAssertEqual(expected, self.sut.grossAmountLabel.text!, "gross amount label should display formatted amount string - \(expected)")
        }
        
        var expectTaxes:XCTestExpectation? = expectation(description: "Wait for update taxes label")
        let observeTaxes = sut.taxesLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.taxesAmount + "(" + viewModel.displayResult.taxesRate + ")"
            
            // Then
            expectTaxes!.fulfill()
            expectTaxes = nil
            XCTAssertEqual(expected, self.sut.taxesLabel.text!, "taxes label should display formatted amount string - \(expected)")
        }
        
        var expectNetAmount:XCTestExpectation? = expectation(description: "Wait for update net amount label")
        let observeNetAmount = sut.netAmountLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.netAmount
            
            // Then
            expectNetAmount!.fulfill()
            expectNetAmount = nil
            XCTAssertEqual(expected, self.sut.netAmountLabel.text!, "net amount label should display formatted amount string - \(expected)")
        }
        
        var expectGrossAmountProfit:XCTestExpectation? = expectation(description: "Wait for update gross amount profit label")
        let observeGrossAmountProfit = sut.grossAmountProfitLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.grossAmountProfit
            
            // Then
            expectGrossAmountProfit!.fulfill()
            expectGrossAmountProfit = nil
            XCTAssertEqual(expected, self.sut.grossAmountProfitLabel.text!, "gross amount profit label should display formatted amount string - \(expected)")
        }
        
        var expectAnnualGrossRateProfit:XCTestExpectation? = expectation(description: "Wait for update annual gross rate profit label")
        let observeAnnualGrossRateProfit = sut.annualGrossRateProfitLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.annualGrossRateProfit
            
            // Then
            expectAnnualGrossRateProfit!.fulfill()
            expectAnnualGrossRateProfit = nil
            XCTAssertEqual(expected, self.sut.annualGrossRateProfitLabel.text!, "annual gross rate profit label should display formatted amount string - \(expected)")
        }
        
        var expectMonthlyGrossRateProfit:XCTestExpectation? = expectation(description: "Wait for update monthly gross rate profit label")
        let observeMonthlyGrossRateProfit = sut.monthlyGrossRateProfitLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.monthlyGrossRateProfit
            
            // Then
            expectMonthlyGrossRateProfit!.fulfill()
            expectMonthlyGrossRateProfit = nil
            XCTAssertEqual(expected, self.sut.monthlyGrossRateProfitLabel.text!, "monthly gross rate profit label should display formatted amount string - \(expected)")
        }
        
        var expectRateProfit:XCTestExpectation? = expectation(description: "Wait for update rate profit label")
        let observeRateProfit = sut.rateProfitLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.rateProfit
            
            // Then
            expectRateProfit!.fulfill()
            expectRateProfit = nil
            XCTAssertEqual(expected, self.sut.rateProfitLabel.text!, "rate profit label should display formatted amount string - \(expected)")
        }
        
        var expectInvestedAmount:XCTestExpectation? = expectation(description: "Wait for update invested amount label")
        let observeInvestedAmount = sut.investedAmountLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.investedAmount
            
            // Then
            expectInvestedAmount!.fulfill()
            expectInvestedAmount = nil
            XCTAssertEqual(expected, self.sut.investedAmountLabel.text!, "invested amount label should display formatted amount string - \(expected)")
        }
        
        var expectMaturityTotalDays:XCTestExpectation? = expectation(description: "Wait for update maturity total days label")
        let observeMaturityTotalDays = sut.maturityTotalDaysLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.maturityTotalDays
            
            // Then
            expectMaturityTotalDays!.fulfill()
            expectMaturityTotalDays = nil
            XCTAssertEqual(expected, self.sut.maturityTotalDaysLabel.text!, "maturity total days label should display formatted amount string - \(expected)")
        }
        
        var expectMaturityDate:XCTestExpectation? = expectation(description: "Wait for update maturity date label")
        let observeMaturityDate = sut.maturityDateLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.maturityDate
            
            // Then
            expectMaturityDate!.fulfill()
            expectMaturityDate = nil
            XCTAssertEqual(expected, self.sut.maturityDateLabel.text!, "maturity date label should display formatted amount string - \(expected)")
        }
        
        var expectRate:XCTestExpectation? = expectation(description: "Wait for update rate label")
        let observeRate = sut.rateLabel.observe(\.text, options: [.new]) { (label, value) in
            
            let expected = viewModel.displayResult.rate
            
            // Then
            expectRate!.fulfill()
            expectRate = nil
            XCTAssertEqual(expected, self.sut.rateLabel.text!, "rate label should display formatted amount string - \(expected)")
        }
        
        wait(for: [expectGrossAmount!,
                   expectTaxes!,
                   expectNetAmount!,
                   expectGrossAmountProfit!,
                   expectAnnualGrossRateProfit!,
                   expectMonthlyGrossRateProfit!,
                   expectRateProfit!,
                   expectInvestedAmount!,
                   expectMaturityTotalDays!,
                   expectMaturityDate!,
                   expectRate!], timeout: 5.0)
    }
}
